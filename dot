#!/bin/bash
# written by Shotaro Fujimoto (https://github.com/ssh0)
# This script manages symbolic for dotfiles.

# You can change the dotfiles to clone
clone_repository='https://github.com/ssh0/dotfiles.git'

dotdir="$HOME/.dotfiles"
configfile="$HOME/.dotfiles/setup_config_link"

usage() {
  cat << EOF

NAME
      dot - manages symbolic link for dotfiles.

USAGE
      dot [-h] <command>

COMMAND
      clone
          Clone ssh0's dotfile repository on your computer.

      pull
          Pull remote dotfile repository (by git).

      set
          Make symbolic link interactively.
          This command sets symbolic links configured in '$configfile'.

      add
          Move the file to the dotfile dir, make the link, and edit '$configfile'.

      unlink
          Unlink the selected symbolic link and copy its original file from the dotfile repository.

      clear
          Remove the all symbolic link in the config file '$configfile'.

OPTION
      -h,--help:    Show this help message.

COMMAND OPTIONS
      clone [<arg>]
          Clone ssh0's repository onto the specified direction.
          default: ~/.dotfiles

      set [-i][-v]
          -i: No interaction mode(skip all conflicts).
          -v: Print verbose messages.

      add [-m <message>] original_file dotfile_direction
          -m <message>: Add your message for setup configuration file.

EOF
  exit 1
}

red=31
yellow=33
blue=34

cecho() {
  color=$1
  shift
  echo -e "\033[${color}m$@\033[00m"
}

makeline(){
  columns=$(tput cols)
  if [ $columns -gt 70 ]; then
    columns=70
  fi
  line=$(printf '%*s\n' "$columns" '' | tr ' ' -)
  echo "${line}"
}

dot_clone(){
  cloneto="${1:-"$HOME/.dotfiles"}"
  cecho $blue "\ngit clone ${clone_repository} ${cloneto}"
  makeline
  read -p "Continue? [y/N]" confirm
  if [ "$confirm" != "y" ]; then
    echo "Aborted."
    exit 1
  fi
  git clone "${clone_repository}" "${cloneto}"
}

dot_pull(){
  # git pull
  cecho $blue "\ncd ${dotdir} && git pull"
  makeline
  cd ${dotdir} && git pull
}

dot_set(){
  interactive=true
  verbose=false

  # option handling
  while getopts iv OPT
  do
    case $OPT in
      "i" ) interactive=false ;;
      "v" ) verbose=true ;;
    esac
  done

  info() {
    if $verbose; then
      # verbose confirmation
      echo ""
      echo "${1} -> ${2}"
    fi
  }

  if $verbose; then
    mklink="ln -sv"
  else
    mklink="ln -s"
  fi

  for l in $(grep -Ev '^#' "$configfile" | grep -Ev '^$'); do
    dotfile="${dotdir}/$(echo "$l" | awk 'BEGIN {FS=","; }  { print $1; }')"
    orig="$HOME/$(echo "$l" | awk 'BEGIN {FS=","; }  { print $2; }')"
    if [ ! -e "${dotfile}" ]; then
      echo ""
      cecho $red "dotfile '${dotfile}' doesn't exist."
      continue
    fi

    # if directory doesn't exist: mkdir or not
    origdir=$(dirname "${orig}")
    if [ ! -d "${origdir}" ]; then
      info "${orig}" "${dotfile}"
      cecho $red "'${origdir}' doesn't exist."
      if $interactive; then
        echo "[message] mkdir '${origdir}'? (y/n):"
        while echo -n ">>> "; read yn; do
          case $yn in
            [Yy] ) mkdir -p "${origdir}"; break ;;
            [Nn] ) break ;;
            * ) echo "Please answer with y or n:" ;;
          esac
        done
      fi
    fi

    # if file already exists: open interaction menu
    if [ -e "${orig}" ]; then
      # if file is link
      if [ -L "${orig}" ]; then
        linkto="$(readlink ${orig})"
        info "${orig}" "${dotfile}"
        # link already exists
        if [ "${linkto}" = "${dotfile}" ]; then
          $verbose && cecho $blue "link '${orig}' already exists."
          continue
        # different link
        else
          cecho $red "link '${orig}' is NOT the link of '${dotfile}'."
          cecho $red "'${orig}' is link of '${linkto}'."
          if $interactive; then
            echo "[message] unlink and re-link for '${orig}'? (y/n):"
            while echo -n ">>> "; read yn; do
              case $yn in
                [Yy] ) unlink "${orig}"
                       $mklink "${dotfile}" "${orig}"
                       break ;;
                [Nn] ) break ;;
                * ) echo "Please answer with y or n:" ;;
              esac
            done
          fi
          continue
        fi
      else
        info "${orig}" "${dotfile}"
        cecho $yellow "'${orig}' already exists."
        if $interactive; then
          while true; do
            echo "(d):show diff, (e):vimdiff, (f):overwrite, (b):make backup, (n):do nothing"
            echo -n ">>> "
            read line
            case $line in
              [Dd] ) echo "diff -u '${dotfile}' '${orig}'"
                     diff -u "${dotfile}" "${orig}"
                     echo ""
                     ;;
              [Ee] ) echo "vimdiff '${dotfile}' '${orig}'"
                     vimdiff "${dotfile}" "${orig}"
                     ;;
              [Ff] ) if [ -d "${orig}" ]; then
                       rm -r "${orig}"
                     else
                       rm "${orig}"
                     fi
                     $mklink "${dotfile}" "${orig}"
                     break
                     ;;
              [Bb] ) $mklink -b --suffix '.bak' "${dotfile}" "${orig}"
                     break
                     ;;
              [Nn] ) break
                     ;;
              # ? ) echo "Please answer with d, f, b or n." ;;
            esac
          done
        fi
      fi
    else
      # otherwise make symbolic file normally
      ln -sv "${dotfile}" "${orig}"
    fi
  done
}

dot_add(){
  home_pattern="s/\/home\/$USER\///"
  dotfile_pattern="s/\/home\/$USER\/\.dotfiles\///"

  # default message
  message=""

  # option handling
  while getopts m:h OPT
  do
    case $OPT in
      "m" ) message="${OPTARG}";;
    esac
  done

  # two arguments must be taken
  shift $((OPTIND-1))
  if [ ! $# = 2 ];then
    usage
  fi

  name="$(basename $1)"
  orig="$(cd $(dirname $1); pwd)"/"${name}"
  dot="$2"

  original="$(echo "$orig" | sed -e "${home_pattern}")"
  dotfile="$(echo "$dot" | sed -e "${dotfile_pattern}")"

  # mv from original path to dotfiles dir
  dotdir="$(dirname "${dot}")"
  if [ ! -e "${dotdir}" ]; then
    mkdir -p "${dotdir}"
  fi
  mv -i "$orig" "$dot"

  # link to orig path from dotfiles
  ln -siv "$dot" "$orig"

  # add the configration to the config file.
  if [ ! "${message}" = "" ]; then
    echo "# ${message}" >> "${configfile}"
  fi
  echo "${dotfile},${original}" >> "${configfile}"

  # Open config file
  if [ ! "$EDITOR" = "" ]; then
    $EDITOR "${configfile}"
  else
    xdg-open "${configfile}"
  fi
}

dot_unlink(){
  for f in $@; do
    if [ ! -L $f ]; then
      echo "'$f' is not symbolic link."
    else
      # Get the file's path
      filename="$(basename $f)"
      currentpath="$(cd $(dirname $f); pwd)"/"${filename}"

      # Get the absolute path
      abspath="$(readlink $f)"

      # Unlink the file
      unlink "$currentpath"

      # Copy the file
      cp "$abspath" "$currentpath"
    fi
  done
}

dot_clear(){
  for l in $(grep -Ev '^#' "${configfile}" | grep -Ev '^$'); do
    orig="$HOME/$(echo "$l" | awk 'BEGIN {FS=","; }  { print $2; }')"
    if [ -L ${orig} ]; then
      echo "unlink ${orig}"
      unlink ${orig}
    fi
  done
}

# main command handling
case "$1" in
  "clone")
    shift 1; dot_clone $@
    ;;
  "pull")
    shift 1; dot_pull $@
    ;;
  "set")
    shift 1; dot_set $@
    ;;
  "add")
    shift 1; dot_add $@
    ;;
  "unlink")
    shift 1; dot_unlink $@
    ;;
  "clear")
    shift 1; dot_clear $@
    ;;
  "-h"|"--help" )
    usage
    ;;
  *)
    echo "command '$1' not found."
    usage
    ;;
esac

